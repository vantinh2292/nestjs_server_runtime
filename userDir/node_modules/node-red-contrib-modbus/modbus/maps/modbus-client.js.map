{"version":3,"sources":["modbus-client.js"],"names":["module","exports","RED","install","mbBasics","require","coreModbusClient","nodes","registerType","this","config","ModbusRTU","defaultTcpUnitId","reconnectTimeMS","serverInfo","clienttype","undefined","bufferCommands","failureLogEnabled","tcpHost","stateLogEnabled","tcpPort","serialPort","serialBaudrate","serialDatabits","serialParity","serialType","serialConnectionDelay","parseInt","serialAsciiResponseStartDelimiter","unit_id","commandDelay","clientTimeout","timeoutTimeMS","serialConnectionDelayTimeMS","reconnectTimeout","parallelUnitIdsAllowed","reconnectOnTimeout","showWarnings","showLogs","node","isFirstInitOfConnection","bufferCommandList","showErrors","sendingAllowed","Map","unitSendingAllowed","verboseWarn","logMessage","stateLog","verboseLog","actualServiceState","settings","value","internalDebug","stateMachine","stateService","actualServiceStateBefore","reconnectTimeoutId","messageAllowedStates","serialSendingAllowed","coreModbusQueue","queueSerialLockCommand","setDefaultUnitId","createStateMachineService","initialState","defaultUnitId","startStateService","setUnitIdFromPayload","unitId","client","msg","Number","minCommandDelayMilliseconds","checkUnitId","updateServerinfo","errorProtocolMsg","logMsgError","err","verbose","queueLogEnabled","state","connectClient","queueSerialUnlockCommand","initQueue","emit","setTimeout","error","payload","logHintText","matches","checkQueuesAreEmpty","send","dequeueCommand","modbusErrorHandling","setTCPConnectionOptions","modbusTcpErrorHandling","message","autoOpen","setNodeStatusTo","Error","connectTCP","port","tcpType","connectC701","then","setTCPConnected","serialPortOptions","baudRate","dataBits","stopBits","parity","startOfSlaveFrameChar","e","modbusSerialErrorHandling","serialStopbits","modbusSerialDebug","toString","setSerialConnectionOptions","errno","connectRTU","connectRTUBuffered","setID","_port","JSON","stringify","networkErrors","includes","customModbusMessage","on","pushToQueueByUnitId","readModbus","code","cberr","isInactive","openSerialClient","writeModbus","onModbusClose","set","queueUnitId","queueLog","queueLength","cb","resolve","reject","setMaxListeners","get","length","invalidPayloadIn","closingModbus","internalDebugLog","nodeIdentifierName","removeAllListeners","info","isOpen","done","Promise","registeredNodeList","registerForModbus","Object","keys","clientUserNodeId","closeConnectionWithoutRegisteredNodes","setStoppedState","name","id","isUndefined","isActive","isReadyToSend","close","httpAdmin","auth","needsPermission","SerialPort","res","json","deregisterForModbus","_","indexOf","req","list","ports"],"mappings":"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","file":"../modbus-client.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020,2021,2022,2023,2024 Klaus Landsdorf (http://node-red.plus/)\n Copyright 2016 - Jason D. Harper, Argonne National Laboratory\n Copyright 2015,2016 - Mika Karaila, Valmet Automation Inc.\n All rights reserved.\n node-red-contrib-modbus\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n\n/**\n * Modbus connection node.\n * @module NodeRedModbusClient\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const coreModbusClient = require('./core/modbus-client-core')\n  const coreModbusQueue = require('./core/modbus-queue-core')\n  const internalDebugLog = require('debug')('contribModbus:config:client')\n  const _ = require('underscore')\n\n  function ModbusClientNode (config) {\n    RED.nodes.createNode(this, config)\n\n    // create an empty modbus client\n    const ModbusRTU = require('@open-p4nr/modbus-serial')\n\n    const unlimitedListeners = 0\n    const minCommandDelayMilliseconds = 1\n    const defaultUnitId = 1\n    const defaultTcpUnitId = 0\n    const serialConnectionDelayTimeMS = 500\n    const timeoutTimeMS = 1000\n    const reconnectTimeMS = 2000\n    const logHintText = ' Get More About It By Logging'\n    const serialAsciiResponseStartDelimiter = '0x3A'\n\n    this.clienttype = config.clienttype\n\n    if (config.parallelUnitIdsAllowed === undefined) {\n      this.bufferCommands = true\n    } else {\n      this.bufferCommands = config.bufferCommands\n    }\n\n    this.queueLogEnabled = config.queueLogEnabled\n    this.stateLogEnabled = config.stateLogEnabled\n    this.failureLogEnabled = config.failureLogEnabled\n\n    this.tcpHost = config.tcpHost\n    this.tcpPort = parseInt(config.tcpPort) || 502\n    this.tcpType = config.tcpType\n\n    this.serialPort = config.serialPort\n    this.serialBaudrate = config.serialBaudrate\n    this.serialDatabits = config.serialDatabits\n    this.serialStopbits = config.serialStopbits\n    this.serialParity = config.serialParity\n    this.serialType = config.serialType\n    this.serialConnectionDelay = parseInt(config.serialConnectionDelay) || serialConnectionDelayTimeMS\n    this.serialAsciiResponseStartDelimiter = config.serialAsciiResponseStartDelimiter || serialAsciiResponseStartDelimiter\n\n    this.unit_id = parseInt(config.unit_id)\n    this.commandDelay = parseInt(config.commandDelay) || minCommandDelayMilliseconds\n    this.clientTimeout = parseInt(config.clientTimeout) || timeoutTimeMS\n    this.reconnectTimeout = parseInt(config.reconnectTimeout) || reconnectTimeMS\n    this.reconnectOnTimeout = config.reconnectOnTimeout\n\n    if (config.parallelUnitIdsAllowed === undefined) {\n      this.parallelUnitIdsAllowed = true\n    } else {\n      this.parallelUnitIdsAllowed = config.parallelUnitIdsAllowed\n    }\n\n    this.showErrors = config.showErrors\n    this.showWarnings = config.showWarnings\n    this.showLogs = config.showLogs\n\n    const node = this\n    node.isFirstInitOfConnection = true\n    node.closingModbus = false\n    node.client = null\n    node.bufferCommandList = new Map()\n    node.sendingAllowed = new Map()\n    node.unitSendingAllowed = []\n    node.messageAllowedStates = coreModbusClient.messageAllowedStates\n    node.serverInfo = ''\n\n    node.stateMachine = null\n    node.stateService = null\n    node.stateMachine = coreModbusClient.createStateMachineService()\n    node.actualServiceState = node.stateMachine.initialState\n    node.actualServiceStateBefore = node.actualServiceState\n    node.stateService = coreModbusClient.startStateService(node.stateMachine)\n    node.reconnectTimeoutId = 0\n    node.serialSendingAllowed = false\n    node.internalDebugLog = internalDebugLog\n\n    coreModbusQueue.queueSerialLockCommand(node)\n\n    node.setDefaultUnitId = function () {\n      if (this.clienttype === 'tcp') {\n        node.unit_id = defaultTcpUnitId\n      } else {\n        node.unit_id = defaultUnitId\n      }\n    }\n\n    node.setUnitIdFromPayload = function (msg) {\n      const unitId = coreModbusClient.getActualUnitId(node, msg)\n      if (!coreModbusClient.checkUnitId(unitId, node.clienttype)) {\n        node.setDefaultUnitId()\n      }\n      node.client.setID(unitId)\n      msg.unitId = unitId\n    }\n\n    if (Number.isNaN(node.unit_id) || !coreModbusClient.checkUnitId(node.unit_id, node.clienttype)) {\n      node.setDefaultUnitId()\n    }\n\n    node.updateServerinfo = function () {\n      if (node.clienttype === 'tcp') {\n        node.serverInfo = ' TCP@' + node.tcpHost + ':' + node.tcpPort\n      } else {\n        node.serverInfo = ' Serial@' + node.serialPort + ':' + node.serialBaudrate + 'bit/s'\n      }\n      node.serverInfo += ' default Unit-Id: ' + node.unit_id\n    }\n\n    function verboseWarn (logMessage) {\n      if (RED.settings.verbose && node.showWarnings) {\n        node.updateServerinfo()\n        node.warn('Client -> ' + logMessage + ' ' + node.serverInfo)\n      }\n    }\n\n    node.errorProtocolMsg = function (err, msg) {\n      if (node.showErrors) {\n        mbBasics.logMsgError(node, err, msg)\n      }\n    }\n\n    function verboseLog (logMessage) {\n      if (RED.settings.verbose && node.showLogs) {\n        coreModbusClient.internalDebug('Client -> ' + logMessage + ' ' + node.serverInfo)\n      }\n    }\n\n    function stateLog (logMessage) {\n      if (node.stateLogEnabled) {\n        verboseLog(logMessage)\n      }\n    }\n\n    node.queueLog = function (logMessage) {\n      if (node.bufferCommands && node.queueLogEnabled) {\n        verboseLog(logMessage)\n      }\n    }\n\n    node.stateService.subscribe(state => {\n      node.actualServiceStateBefore = node.actualServiceState\n      node.actualServiceState = state\n      stateLog(state.value)\n\n      if (!state.value || node.actualServiceState.value === undefined) {\n        // verboseWarn('fsm ignore invalid state')\n        return\n      }\n\n      if (node.actualServiceStateBefore.value === node.actualServiceState.value) {\n        // verboseWarn('fsm ignore equal state ' + node.actualServiceState.value + ' after ' + node.actualServiceStateBefore.value)\n        return\n      }\n\n      if (state.matches('init')) {\n        verboseWarn('fsm init state after ' + node.actualServiceStateBefore.value)\n        node.updateServerinfo()\n        coreModbusQueue.initQueue(node)\n        node.reconnectTimeoutId = 0\n\n        try {\n          if (node.isFirstInitOfConnection) {\n            node.isFirstInitOfConnection = false\n            verboseWarn('first fsm init in ' + serialConnectionDelayTimeMS + ' ms')\n            setTimeout(node.connectClient, serialConnectionDelayTimeMS)\n          } else {\n            verboseWarn('fsm init in ' + node.reconnectTimeout + ' ms')\n            setTimeout(node.connectClient, node.reconnectTimeout)\n          }\n        } catch (err) {\n          node.error(err, { payload: 'client connection error ' + logHintText })\n        }\n\n        node.emit('mbinit')\n      }\n\n      if (state.matches('connected')) {\n        verboseWarn('fsm connected after state ' + node.actualServiceStateBefore.value + logHintText)\n        coreModbusQueue.queueSerialUnlockCommand(node)\n        node.emit('mbconnected')\n      }\n\n      if (state.matches('activated')) {\n        node.emit('mbactive')\n        if (node.bufferCommands && !coreModbusQueue.checkQueuesAreEmpty(node)) {\n          node.stateService.send('QUEUE')\n        }\n      }\n\n      if (state.matches('queueing')) {\n        if (node.clienttype === 'tcp') {\n          node.stateService.send('SEND')\n        } else {\n          if (node.serialSendingAllowed) {\n            coreModbusQueue.queueSerialLockCommand(node)\n            node.stateService.send('SEND')\n          }\n        }\n      }\n\n      if (state.matches('sending')) {\n        setTimeout(() => {\n          coreModbusQueue.dequeueCommand(node)\n        }, node.commandDelay)\n        node.emit('mbqueue')\n      }\n\n      if (state.matches('opened')) {\n        coreModbusQueue.queueSerialUnlockCommand(node)\n        node.emit('mbopen')\n      }\n\n      if (state.matches('switch')) {\n        node.emit('mbswitch')\n        node.stateService.send('CLOSE')\n      }\n\n      if (state.matches('closed')) {\n        node.emit('mbclosed')\n        node.stateService.send('RECONNECT')\n      }\n\n      if (state.matches('stopped')) {\n        verboseWarn('stopped state without reconnecting')\n        node.emit('mbclosed')\n      }\n\n      if (state.matches('failed')) {\n        verboseWarn('fsm failed state after ' + node.actualServiceStateBefore.value + logHintText)\n        node.emit('mberror', 'Modbus Failure On State ' + node.actualServiceStateBefore.value + logHintText)\n        node.stateService.send('BREAK')\n      }\n\n      if (state.matches('broken')) {\n        verboseWarn('fsm broken state after ' + node.actualServiceStateBefore.value + logHintText)\n        node.emit('mbbroken', 'Modbus Broken On State ' + node.actualServiceStateBefore.value + logHintText)\n        if (node.reconnectOnTimeout) {\n          node.stateService.send('RECONNECT')\n        } else {\n          node.stateService.send('ACTIVATE')\n        }\n      }\n\n      if (state.matches('reconnecting')) {\n        verboseWarn('fsm reconnect state after ' + node.actualServiceStateBefore.value + logHintText)\n        coreModbusQueue.queueSerialLockCommand(node)\n        node.emit('mbreconnecting')\n        if (node.reconnectTimeout <= 0) {\n          node.reconnectTimeout = reconnectTimeMS\n        }\n        setTimeout(() => {\n          node.reconnectTimeoutId = 0\n          node.stateService.send('INIT')\n        }, node.reconnectTimeout)\n      }\n    })\n\n    node.connectClient = function () {\n      try {\n        if (node.client) {\n          try {\n            node.client.close(function () {\n              verboseLog('connection closed')\n            })\n            verboseLog('connection close sent')\n          } catch (err) {\n            verboseLog(err.message)\n          }\n        }\n        node.client = null\n        node.client = new ModbusRTU()\n\n        node.client.on('error', (err) => {\n          node.modbusErrorHandling(err)\n          mbBasics.setNodeStatusTo('error', node)\n        })\n\n        if (!node.clientTimeout) {\n          node.clientTimeout = timeoutTimeMS\n        }\n\n        if (!node.reconnectTimeout) {\n          node.reconnectTimeout = reconnectTimeMS\n        }\n\n        if (node.clienttype === 'tcp') {\n          if (!coreModbusClient.checkUnitId(node.unit_id, node.clienttype)) {\n            node.error(new Error('wrong unit-id (0..255)'), { payload: node.unit_id })\n            node.stateService.send('FAILURE')\n            return false\n          }\n\n          try {\n            switch (node.tcpType) {\n              case 'C701':\n                verboseLog('C701 port UDP bridge')\n                node.client.connectC701(node.tcpHost, {\n                  port: node.tcpPort,\n                  autoOpen: true\n                }).then(node.setTCPConnectionOptions)\n                  .then(node.setTCPConnected)\n                  .catch((err) => {\n                    node.modbusTcpErrorHandling(err)\n                    return false\n                  })\n                break\n              case 'TELNET':\n                verboseLog('Telnet port')\n                node.client.connectTelnet(node.tcpHost, {\n                  port: node.tcpPort,\n                  autoOpen: true\n                }).then(node.setTCPConnectionOptions)\n                  .catch((err) => {\n                    node.modbusTcpErrorHandling(err)\n                    return false\n                  })\n                break\n              case 'TCP-RTU-BUFFERED':\n                verboseLog('TCP RTU buffered port')\n                node.client.connectTcpRTUBuffered(node.tcpHost, {\n                  port: node.tcpPort,\n                  autoOpen: true\n                }).then(node.setTCPConnectionOptions)\n                  .catch((err) => {\n                    node.modbusTcpErrorHandling(err)\n                    return false\n                  })\n                break\n              default:\n                verboseLog('TCP port')\n                node.client.connectTCP(node.tcpHost, {\n                  port: node.tcpPort,\n                  autoOpen: true\n                }).then(node.setTCPConnectionOptions)\n                  .catch((err) => {\n                    node.modbusTcpErrorHandling(err)\n                    return false\n                  })\n            }\n          } catch (e) {\n            node.modbusTcpErrorHandling(e)\n            return false\n          }\n        } else {\n          if (!coreModbusClient.checkUnitId(node.unit_id, node.clienttype)) {\n            node.error(new Error('wrong unit-id serial (0..247)'), { payload: node.unit_id })\n            node.stateService.send('FAILURE')\n            return false\n          }\n\n          if (!node.serialConnectionDelay) {\n            node.serialConnectionDelay = serialConnectionDelayTimeMS\n          }\n\n          if (!node.serialPort) {\n            node.error(new Error('wrong serial port'), { payload: node.serialPort })\n            node.stateService.send('FAILURE')\n            return false\n          }\n\n          const serialPortOptions = {\n            baudRate: parseInt(node.serialBaudrate),\n            dataBits: parseInt(node.serialDatabits),\n            stopBits: parseInt(node.serialStopbits),\n            parity: node.serialParity,\n            autoOpen: false\n          }\n\n          try {\n            switch (node.serialType) {\n              case 'ASCII':\n                verboseLog('ASCII port serial')\n                // Make sure is parsed when string, otherwise just assign.\n                if (node.serialAsciiResponseStartDelimiter && typeof node.serialAsciiResponseStartDelimiter === 'string') {\n                  serialPortOptions.startOfSlaveFrameChar = parseInt(node.serialAsciiResponseStartDelimiter, 16)\n                } else {\n                  serialPortOptions.startOfSlaveFrameChar = node.serialAsciiResponseStartDelimiter\n                }\n                verboseLog('Using response delimiter: 0x' + serialPortOptions.startOfSlaveFrameChar.toString(16))\n\n                node.client.connectAsciiSerial(node.serialPort, serialPortOptions).then(node.setSerialConnectionOptions)\n                  .catch((err) => {\n                    node.modbusSerialErrorHandling(err)\n                    return false\n                  })\n                break\n              case 'RTU':\n                verboseLog('RTU port serial')\n                node.client.connectRTU(node.serialPort, serialPortOptions).then(node.setSerialConnectionOptions)\n                  .catch((err) => {\n                    node.modbusSerialErrorHandling(err)\n                    return false\n                  })\n                break\n              default:\n                verboseLog('RTU buffered port serial')\n                node.client.connectRTUBuffered(node.serialPort, serialPortOptions).then(node.setSerialConnectionOptions)\n                  .catch((err) => {\n                    node.modbusSerialErrorHandling(err)\n                    return false\n                  })\n                break\n            }\n          } catch (e) {\n            node.modbusSerialErrorHandling(e)\n            return false\n          }\n        }\n      } catch (err) {\n        node.modbusErrorHandling(err)\n        return false\n      }\n\n      return true\n    }\n\n    node.setTCPConnectionOptions = function () {\n      node.client.setID(node.unit_id)\n      node.client.setTimeout(node.clientTimeout)\n      node.stateService.send('CONNECT')\n    }\n\n    node.setTCPConnected = function () {\n      coreModbusClient.modbusSerialDebug('modbus tcp connected on ' + node.tcpHost)\n    }\n\n    node.setSerialConnectionOptions = function () {\n      node.stateService.send('OPENSERIAL')\n      setTimeout(node.openSerialClient, parseInt(node.serialConnectionDelay))\n    }\n\n    node.modbusErrorHandling = function (err) {\n      coreModbusQueue.queueSerialUnlockCommand(node)\n      if (err.message) {\n        coreModbusClient.modbusSerialDebug('modbusErrorHandling:' + err.message)\n      } else {\n        coreModbusClient.modbusSerialDebug('modbusErrorHandling:' + JSON.stringify(err))\n      }\n      if (err.errno && coreModbusClient.networkErrors.includes(err.errno)) {\n        node.stateService.send('FAILURE')\n      }\n    }\n\n    node.modbusTcpErrorHandling = function (err) {\n      coreModbusQueue.queueSerialUnlockCommand(node)\n      if (node.showErrors) {\n        node.error(err)\n      }\n\n      if (node.failureLogEnabled) {\n        if (err.message) {\n          coreModbusClient.modbusSerialDebug('modbusTcpErrorHandling:' + err.message)\n        } else {\n          coreModbusClient.modbusSerialDebug('modbusTcpErrorHandling:' + JSON.stringify(err))\n        }\n      }\n\n      if ((err.errno && coreModbusClient.networkErrors.includes(err.errno)) ||\n      (err.code && coreModbusClient.networkErrors.includes(err.code))) {\n        node.stateService.send('BREAK')\n      }\n    }\n\n    node.modbusSerialErrorHandling = function (err) {\n      coreModbusQueue.queueSerialUnlockCommand(node)\n      if (node.showErrors) {\n        node.error(err)\n      }\n\n      if (node.failureLogEnabled) {\n        if (err.message) {\n          coreModbusClient.modbusSerialDebug('modbusSerialErrorHandling:' + err.message)\n        } else {\n          coreModbusClient.modbusSerialDebug('modbusSerialErrorHandling:' + JSON.stringify(err))\n        }\n      }\n\n      node.stateService.send('BREAK')\n    }\n\n    node.openSerialClient = function () {\n      // some delay for windows\n      if (node.actualServiceState.value === 'opened') {\n        verboseLog('time to open Unit ' + node.unit_id)\n        coreModbusClient.modbusSerialDebug('modbus connection opened')\n        node.client.setID(node.unit_id)\n        node.client.setTimeout(parseInt(node.clientTimeout))\n        node.client._port.on('close', node.onModbusClose)\n        node.stateService.send('CONNECT')\n      } else {\n        verboseLog('wrong state on connect serial ' + node.actualServiceState.value)\n        coreModbusClient.modbusSerialDebug('modbus connection not opened state is %s', node.actualServiceState.value)\n        node.stateService.send('BREAK')\n      }\n    }\n\n    node.onModbusClose = function () {\n      coreModbusQueue.queueSerialUnlockCommand(node)\n      verboseWarn('Modbus closed port')\n      coreModbusClient.modbusSerialDebug('modbus closed port')\n      node.stateService.send('CLOSE')\n    }\n\n    node.on('customModbusMessage', function (msg, cb, cberr) {\n      // const state = node.actualServiceState\n      coreModbusClient.customModbusMessage(node, msg, cb, cberr)\n    })\n    node.on('readModbus', function (msg, cb, cberr) {\n      const state = node.actualServiceState\n      if (node.isInactive()) {\n        cberr(new Error('Client Not Ready To Read At State ' + state.value), msg)\n      } else {\n        if (node.bufferCommands) {\n          coreModbusQueue.pushToQueueByUnitId(node, coreModbusClient.readModbus, msg, cb, cberr).then(function () {\n            node.queueLog(JSON.stringify({\n              info: 'queued read msg',\n              message: msg.payload,\n              state: state.value,\n              queueLength: node.bufferCommandList.get(msg.queueUnitId).length\n            }))\n          }).catch(function (err) {\n            cberr(err, msg)\n          }).finally(function () {\n            node.stateService.send('QUEUE')\n          })\n        } else {\n          coreModbusClient.readModbus(node, msg, cb, cberr)\n        }\n      }\n    })\n\n    node.on('writeModbus', function (msg, cb, cberr) {\n      const state = node.actualServiceState\n\n      if (node.isInactive()) {\n        cberr(new Error('Client Not Ready To Write At State ' + state.value), msg)\n      } else {\n        if (node.bufferCommands) {\n          coreModbusQueue.pushToQueueByUnitId(node, coreModbusClient.writeModbus, msg, cb, cberr).then(function () {\n            node.queueLog(JSON.stringify({\n              info: 'queued write msg',\n              message: msg.payload,\n              state: state.value,\n              queueLength: node.bufferCommandList.get(msg.queueUnitId).length\n            }))\n          }).catch(function (err) {\n            cberr(err, msg)\n          }).finally(function () {\n            node.stateService.send('QUEUE')\n          })\n        } else {\n          coreModbusClient.writeModbus(node, msg, cb, cberr)\n        }\n      }\n    })\n\n    node.activateSending = function (msg) {\n      node.sendingAllowed.set(msg.queueUnitId, true)\n      coreModbusQueue.queueSerialUnlockCommand(node)\n\n      return new Promise(\n        function (resolve, reject) {\n          try {\n            if (node.bufferCommands) {\n              node.queueLog(JSON.stringify({\n                info: 'queue response activate sending',\n                queueLength: node.bufferCommandList.length,\n                sendingAllowed: node.sendingAllowed.get(msg.queueUnitId),\n                serialSendingAllowed: node.serialSendingAllowed,\n                queueUnitId: msg.queueUnitId\n              }))\n\n              if (coreModbusQueue.checkQueuesAreEmpty(node)) {\n                node.stateService.send('EMPTY')\n              }\n            }\n            resolve()\n          } catch (err) {\n            reject(err)\n          }\n        })\n    }\n\n    verboseLog('initialized')\n    node.setMaxListeners(unlimitedListeners)\n\n    node.on('reconnect', function () {\n      node.stateService.send('CLOSE')\n    })\n\n    node.on('dynamicReconnect', function (msg, cb, cberr) {\n      if (mbBasics.invalidPayloadIn(msg)) {\n        throw new Error('Message Or Payload Not Valid')\n      }\n\n      coreModbusClient.internalDebug('Dynamic Reconnect Parameters ' + JSON.stringify(msg.payload))\n      if (coreModbusClient.setNewNodeSettings(node, msg)) {\n        cb(msg)\n      } else {\n        cberr(new Error('Message Or Payload Not Valid'), msg)\n      }\n      coreModbusClient.internalDebug('Dynamic Reconnect Starts on actual state ' + node.actualServiceState.value)\n      node.stateService.send('SWITCH')\n    })\n\n    node.on('close', function (done) {\n      const nodeIdentifierName = node.name || node.id\n      node.closingModbus = true\n      verboseLog('stop fsm on close ' + nodeIdentifierName)\n      node.stateService.send('STOP')\n      verboseLog('close node ' + nodeIdentifierName)\n      node.internalDebugLog('close node ' + nodeIdentifierName)\n      node.removeAllListeners()\n      if (node.client) {\n        if (node.client.isOpen) {\n          node.client.close(function (err) {\n            if (err) {\n              verboseLog('Connection closed with error ' + nodeIdentifierName)\n            } else {\n              verboseLog('Connection closed well ' + nodeIdentifierName)\n            }\n            done()\n          })\n        } else {\n          verboseLog('connection was closed ' + nodeIdentifierName)\n          done()\n        }\n      } else {\n        verboseLog('Connection closed simple ' + nodeIdentifierName)\n        done()\n      }\n    })\n\n    // handle using as config node\n    node.registeredNodeList = {}\n\n    node.registerForModbus = function (clientUserNodeId) {\n      node.registeredNodeList[clientUserNodeId] = clientUserNodeId\n      if (Object.keys(node.registeredNodeList).length === 1) {\n        node.closingModbus = false\n        node.stateService.send('NEW')\n        node.stateService.send('INIT')\n      }\n      node.emit('mbregister', clientUserNodeId)\n    }\n\n    node.setStoppedState = function (clientUserNodeId, done) {\n      node.stateService.send('STOP')\n      node.emit('mbderegister', clientUserNodeId)\n      done()\n    }\n\n    node.closeConnectionWithoutRegisteredNodes = function (clientUserNodeId, done) {\n      if (Object.keys(node.registeredNodeList).length === 0) {\n        node.closingModbus = true\n        if (node.client && node.actualServiceState.value !== 'stopped') {\n          if (node.client.isOpen) {\n            node.client.close(function () {\n              node.setStoppedState(clientUserNodeId, done)\n            })\n          } else {\n            node.setStoppedState(clientUserNodeId, done)\n          }\n        } else {\n          node.setStoppedState(clientUserNodeId, done)\n        }\n      } else {\n        node.setStoppedState(clientUserNodeId, done)\n      }\n    }\n\n    node.deregisterForModbus = function (clientUserNodeId, done) {\n      try {\n        delete node.registeredNodeList[clientUserNodeId]\n        if (node.closingModbus) {\n          done()\n          node.emit('mbderegister', clientUserNodeId)\n        } else {\n          node.closeConnectionWithoutRegisteredNodes(clientUserNodeId, done)\n        }\n      } catch (err) {\n        verboseWarn(err.message + ' on de-register node ' + clientUserNodeId)\n        node.error(err)\n        done()\n      }\n    }\n\n    node.isInactive = function () {\n      return _.isUndefined(node.actualServiceState) || node.messageAllowedStates.indexOf(node.actualServiceState.value) === -1\n    }\n\n    node.isActive = function () {\n      return !node.isInactive()\n    }\n\n    node.isReadyToSend = function (node) {\n      if (node.actualServiceState.matches('queueing')) {\n        return true\n      }\n      verboseWarn('Client not ready to send')\n      return false\n    }\n  }\n\n  RED.nodes.registerType('modbus-client', ModbusClientNode)\n\n  RED.httpAdmin.get('/modbus/serial/ports', RED.auth.needsPermission('serial.read'), function (req, res) {\n    const SerialPort = require('serialport')\n    SerialPort.SerialPort.list().then(ports => {\n      res.json(ports)\n    }).catch(err => {\n      res.json([err.message])\n      coreModbusClient.internalDebug(err.message)\n    })\n  })\n}\n"]}