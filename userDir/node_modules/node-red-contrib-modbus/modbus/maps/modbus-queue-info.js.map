{"version":3,"sources":["modbus-queue-info.js"],"names":["module","exports","RED","install","mbBasics","require","coreModbusQueue","nodes","registerType","internalDebugLog","createNode","this","name","config","topic","unitid","parseInt","lowLowLevel","lowLevel","highLevel","highHighLevel","errorOnHighLevel","queueReadIntervalTime","showStatusActivities","updateOnAllQueueChanges","node","queueReadInterval","modbusClient","updateStatusRrunning","unitsWithQueue","Map","setNodeStatusTo","getNode","server","unit","set","resetStates","unitWithQueue","highLevelReached","highHighLevelReached","get","lowLowLevelReached","errorProtocolMsg","err","showErrors","logMsgError","initUnitQueueStates","msg","checkLowLevelReached","bufferCommandListLength","modbusClientName","now","state","checkHighLevelReached","payload","Date","warn","id","checkHighHighLevelReached","error","Error","getStatusSituationFillColor","fillColor","send","setNodeStatusByActivity","lowLevelReached","bufferCommands","Promise","resolve","status","fill","shape","reject","text","readFromQueue","length","checkQueueStates","readFromAllUnitQueues","registerModbusQueueActionsToNode","on","eventCallback","removeModbusQueueActionsFromNode","removeListener","updateOnAllUnitQueues","queues","bufferCommandList","resetQueue","msgUnitId","unitId","setInterval","sendEmptyMsgOnFail","date","lowlowLevel","msgQueueReset","settings","infoText","allQueueData","queue","clearInterval","setNodeDefaultStatus","initQueue","verbose","queueOptions","done","deregisterForModbus"],"mappings":"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","file":"../modbus-queue-info.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020,2021,2022,2023,2024 Klaus Landsdorf (http://node-red.plus/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n **/\n\n/**\n * Modbus Read node.\n * @module NodeRedModbusRead\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const coreModbusQueue = require('./core/modbus-queue-core')\n  const internalDebugLog = require('debug')('contribModbus:queue')\n\n  function ModbusQueueInfo (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.topic = config.topic\n    this.unitid = parseInt(config.unitid) || 1\n    this.lowLowLevel = parseInt(config.lowLowLevel)\n    this.lowLevel = parseInt(config.lowLevel)\n    this.highLevel = parseInt(config.highLevel)\n    this.highHighLevel = parseInt(config.highHighLevel)\n    this.errorOnHighLevel = config.errorOnHighLevel\n    this.queueReadIntervalTime = config.queueReadIntervalTime || 1000\n    this.showStatusActivities = config.showStatusActivities\n    this.updateOnAllQueueChanges = config.updateOnAllQueueChanges\n    this.updateOnAllUnitQueues = config.updateOnAllUnitQueues\n\n    this.internalDebugLog = internalDebugLog\n\n    const node = this\n    node.queueReadInterval = null\n    node.updateStatusRrunning = false\n    node.unitsWithQueue = new Map()\n    mbBasics.setNodeStatusTo('waiting', node)\n\n    const modbusClient = RED.nodes.getNode(config.server)\n    if (!modbusClient) {\n      return\n    }\n    modbusClient.registerForModbus(node)\n\n    node.initUnitQueueStates = function () {\n      for (let unit = 0; unit < 256; unit += 1) {\n        node.unitsWithQueue.set(unit, {})\n        node.resetStates(unit)\n      }\n    }\n\n    node.resetStates = function (unit) {\n      const unitWithQueue = node.unitsWithQueue.get(unit)\n      unitWithQueue.lowLowLevelReached = true\n      unitWithQueue.lowLevelReached = false\n      unitWithQueue.highLevelReached = false\n      unitWithQueue.highHighLevelReached = false\n    }\n\n    node.errorProtocolMsg = function (err, msg) {\n      if (node.showErrors) {\n        mbBasics.logMsgError(node, err, msg)\n      }\n    }\n\n    node.initUnitQueueStates()\n\n    node.checkLowLevelReached = function (node, bufferCommandListLength, unit) {\n      const unitWithQueue = node.unitsWithQueue.get(unit)\n      if (!unitWithQueue.lowLevelReached && bufferCommandListLength > node.lowLowLevel && bufferCommandListLength < node.lowLevel) {\n        unitWithQueue.lowLevelReached = true\n        const msg = {\n          payload: Date.now(),\n          topic: node.topic,\n          state: 'low level reached',\n          unitid: unit,\n          modbusClientName: modbusClient.name,\n          bufferCommandListLength\n        }\n        node.send(msg)\n      }\n    }\n\n    node.checkHighLevelReached = function (node, bufferCommandListLength, unit) {\n      const unitWithQueue = node.unitsWithQueue.get(unit)\n      if (!unitWithQueue.highLevelReached &&\n        bufferCommandListLength > node.lowLevel &&\n        bufferCommandListLength > node.highLevel) {\n        unitWithQueue.highLevelReached = true\n        const msg = {\n          payload: Date.now(),\n          topic: node.topic,\n          state: 'high level reached',\n          unitid: unit,\n          modbusClientName: modbusClient.name || modbusClient.id,\n          highLevel: node.highLevel,\n          bufferCommandListLength\n        }\n\n        if (node.errorOnHighLevel) {\n          node.error(new Error('Queue High Level Reached'), msg)\n        } else {\n          node.warn(msg)\n        }\n\n        node.send(msg)\n      }\n    }\n\n    node.checkHighHighLevelReached = function (node, bufferCommandListLength, unit) {\n      const unitWithQueue = node.unitsWithQueue.get(unit)\n      if (!unitWithQueue.highHighLevelReached &&\n        bufferCommandListLength > node.highLevel &&\n        bufferCommandListLength > node.highHighLevel) {\n        unitWithQueue.highHighLevelReached = true\n        const msg = {\n          payload: Date.now(),\n          topic: node.topic,\n          state: 'high high level reached',\n          unitid: unit,\n          modbusClientName: modbusClient.name || modbusClient.id,\n          highLevel: node.highLevel,\n          highHighLevel: node.highHighLevel,\n          bufferCommandListLength\n        }\n        node.error(new Error('Queue High High Level Reached'), msg)\n        node.send(msg)\n      }\n    }\n\n    node.getStatusSituationFillColor = function (unit) {\n      const unitWithQueue = node.unitsWithQueue.get(unit)\n      let fillColor = 'blue'\n\n      if (unitWithQueue.lowLevelReached) {\n        fillColor = 'green'\n      }\n\n      if (unitWithQueue.highLevelReached) {\n        if (node.errorOnHighLevel) {\n          fillColor = 'red'\n        } else {\n          fillColor = 'yellow'\n        }\n      }\n\n      if (unitWithQueue.highHighLevelReached) {\n        fillColor = 'red'\n      }\n\n      return fillColor\n    }\n\n    node.setNodeStatusByActivity = function (bufferCommandListLength, unit) {\n      if (node.showStatusActivities) {\n        node.status({\n          fill: node.getStatusSituationFillColor(node.unitid),\n          shape: 'ring',\n          text: (bufferCommandListLength) ? 'active unit ' + unit + ' queue items: ' + bufferCommandListLength : 'active (Unit-Id: ' + unit + ') empty'\n        })\n      }\n    }\n\n    node.readFromQueue = function () {\n      if (node.updateStatusRrunning) {\n        return\n      }\n      const unit = ((node.unitid < 1 || node.unitid > 255)) ? 1 : node.unitid\n      if (modbusClient.bufferCommands) {\n        return new Promise(\n          function (resolve, reject) {\n            try {\n              node.updateStatusRrunning = true\n              const bufferCommandListLength = modbusClient.bufferCommandList.get(unit).length\n              node.checkQueueStates(bufferCommandListLength, unit)\n              node.setNodeStatusByActivity(bufferCommandListLength, unit)\n              node.updateStatusRrunning = false\n              resolve()\n            } catch (err) {\n              node.updateStatusRrunning = false\n              reject(err)\n            }\n          })\n      } else {\n        if (node.showStatusActivities) {\n          node.setNodeStatusByActivity(null, unit)\n        }\n      }\n    }\n\n    node.checkQueueStates = function (bufferCommandListLength, unit) {\n      const unitWithQueue = node.unitsWithQueue.get(unit)\n      if (!unitWithQueue.lowLowLevelReached && bufferCommandListLength < node.lowLowLevel) {\n        node.resetStates(unit)\n      }\n      node.checkLowLevelReached(node, bufferCommandListLength, unit)\n      node.checkHighLevelReached(node, bufferCommandListLength, unit)\n      node.checkHighHighLevelReached(node, bufferCommandListLength, unit)\n    }\n\n    node.readFromAllUnitQueues = function () {\n      if (node.updateStatusRrunning) {\n        return\n      }\n\n      if (modbusClient.bufferCommands) {\n        return new Promise(\n          function (resolve, reject) {\n            try {\n              node.updateStatusRrunning = true\n              let bufferCommandListLength = 0\n              for (let unit = 0; unit < 256; unit += 1) {\n                bufferCommandListLength = modbusClient.bufferCommandList.get(unit).length\n                if (!bufferCommandListLength) {\n                  continue\n                }\n                node.checkQueueStates(bufferCommandListLength, unit)\n              }\n              node.updateStatusRrunning = false\n              resolve()\n            } catch (err) {\n              node.updateStatusRrunning = false\n              reject(err)\n            }\n          })\n      }\n    }\n\n    node.registerModbusQueueActionsToNode = function (eventCallback) {\n      if (node.updateOnAllQueueChanges) { // much more CPU-Load on many parallel requests to the client\n        modbusClient.on('mbqueue', eventCallback) // en-queue\n      }\n      modbusClient.on('mbactive', eventCallback) // de-queue\n      modbusClient.on('mbinit', eventCallback)\n      modbusClient.on('mbconnected', eventCallback)\n      modbusClient.on('mberror', eventCallback)\n      modbusClient.on('mbclosed', eventCallback)\n      node.queueReadInterval = setInterval(eventCallback, node.queueReadIntervalTime)\n    }\n\n    node.removeModbusQueueActionsFromNode = function (eventCallback) {\n      modbusClient.removeListener('mbqueue', eventCallback)\n      modbusClient.removeListener('mbactive', eventCallback)\n      modbusClient.removeListener('mbinit', eventCallback)\n      modbusClient.removeListener('mbconnected', eventCallback)\n      modbusClient.removeListener('mberror', eventCallback)\n      modbusClient.removeListener('mbclosed', eventCallback)\n    }\n\n    if (node.updateOnAllUnitQueues) {\n      node.registerModbusQueueActionsToNode(node.readFromAllUnitQueues)\n      mbBasics.setNodeStatusTo('active for all queues', node)\n    } else {\n      node.registerModbusQueueActionsToNode(node.readFromQueue)\n    }\n\n    node.on('input', function (msg) {\n      let msgUnitId = node.unitid\n      msg.payload = {}\n      msg.payload.queueEnabled = modbusClient.bufferCommands\n\n      if (node.updateOnAllUnitQueues) {\n        msg.payload.allQueueData = true\n        msg.payload.queues = modbusClient.bufferCommandList\n      } else {\n        try {\n          if (msg.payload.resetQueue) {\n            msgUnitId = parseInt(msg.payload.unitId) || node.unitid\n          } else {\n            msgUnitId = parseInt(msg.payload) || node.unitid\n          }\n        } catch (err) {\n          node.errorProtocolMsg(err, msg)\n          mbBasics.sendEmptyMsgOnFail(node, err, msg)\n          msgUnitId = node.unitid\n        }\n        msg.payload.allQueueData = false\n        msg.payload.unitid = msgUnitId\n        msg.payload.queue = modbusClient.bufferCommandList.get(msgUnitId)\n      }\n\n      msg.payload.queueOptions = {\n        date: Date.now(),\n        state: 'queue request',\n        modbusClientName: modbusClient.name || modbusClient.id,\n        lowlowLevel: node.lowlowLevel,\n        unitId: msgUnitId,\n        lowLevel: node.lowLevel,\n        highLevel: node.highLevel,\n        highHighLevel: node.highHighLevel\n      }\n\n      const msgQueueReset = msg.payload.resetQueue || msg.resetQueue\n      if (msgQueueReset && modbusClient.bufferCommands) {\n        coreModbusQueue.initQueue(modbusClient)\n        if (RED.settings.verbose) {\n          const infoText = 'Init Queue By External Node'\n          modbusClient.warn(infoText)\n          internalDebugLog(infoText)\n        }\n        node.initUnitQueueStates()\n\n        if (node.showStatusActivities) {\n          node.status({\n            fill: 'blue',\n            shape: 'ring',\n            text: 'active empty unit queue'\n          })\n        }\n        msg.payload.queueOptions.state = 'queue reset done'\n      }\n\n      node.send(msg)\n    })\n\n    node.on('close', function (done) {\n      if (node.updateOnAllUnitQueues) {\n        node.removeModbusQueueActionsFromNode(node.readFromAllUnitQueues)\n      } else {\n        node.removeModbusQueueActionsFromNode(node.readFromQueue)\n      }\n      mbBasics.setNodeStatusTo('closed', node)\n      if (node.queueReadInterval) {\n        clearInterval(node.queueReadInterval)\n      }\n      node.queueReadInterval = null\n      modbusClient.deregisterForModbus(node.id, done)\n    })\n\n    if (!node.showStatusActivities) {\n      mbBasics.setNodeDefaultStatus(node)\n    }\n  }\n\n  RED.nodes.registerType('modbus-queue-info', ModbusQueueInfo)\n}\n"]}